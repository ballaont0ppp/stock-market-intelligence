/**
 * Security Vulnerability Scanner
 * 
 * These tests identify common security vulnerabilities in web applications
 */

// Mock vulnerability database
const knownVulnerabilities = {
  'sql-injection': {
    name: 'SQL Injection',
    severity: 'High',
    description: 'Application is vulnerable to SQL injection attacks',
    detection: 'Input validation missing for database queries'
  },
  'xss': {
    name: 'Cross-Site Scripting (XSS)',
    severity: 'Medium',
    description: 'Application is vulnerable to cross-site scripting attacks',
    detection: 'User input is not properly sanitized before output'
  },
  'csrf': {
    name: 'Cross-Site Request Forgery',
    severity: 'Medium',
    description: 'Application lacks CSRF protection tokens',
    detection: 'Forms do not include anti-CSRF tokens'
  },
  'weak-password-policy': {
    name: 'Weak Password Policy',
    severity: 'Low',
    description: 'Application allows weak passwords',
    detection: 'Password requirements are not enforced'
  },
  'missing-headers': {
    name: 'Missing Security Headers',
    severity: 'Low',
    description: 'Application does not set security headers',
    detection: 'Missing X-Content-Type-Options, X-Frame-Options, etc.'
  }
};

// Mock security scanner
class SecurityScanner {
  constructor(targetUrl) {
    this.targetUrl = targetUrl;
    this.findings = [];
  }
  
  async scanForSqlInjection() {
    console.log('Scanning for SQL Injection vulnerabilities...');
    
    // Simulate scanning logic
    const vulnerable = Math.random() > 0.8; // 20% chance of finding vulnerability
    
    if (vulnerable) {
      this.findings.push({
        ...knownVulnerabilities['sql-injection'],
        url: this.targetUrl,
        timestamp: new Date()
      });
    }
    
    return vulnerable;
  }
  
  async scanForXSS() {
    console.log('Scanning for XSS vulnerabilities...');
    
    // Simulate scanning logic
    const vulnerable = Math.random() > 0.7; // 30% chance of finding vulnerability
    
    if (vulnerable) {
      this.findings.push({
        ...knownVulnerabilities['xss'],
        url: this.targetUrl,
        timestamp: new Date()
      });
    }
    
    return vulnerable;
  }
  
  async scanForCSRF() {
    console.log('Scanning for CSRF vulnerabilities...');
    
    // Simulate scanning logic
    const vulnerable = Math.random() > 0.9; // 10% chance of finding vulnerability
    
    if (vulnerable) {
      this.findings.push({
        ...knownVulnerabilities['csrf'],
        url: this.targetUrl,
        timestamp: new Date()
      });
    }
    
    return vulnerable;
  }
  
  async scanForWeakPasswords() {
    console.log('Scanning for weak password policy...');
    
    // Simulate scanning logic
    const vulnerable = Math.random() > 0.6; // 40% chance of finding vulnerability
    
    if (vulnerable) {
      this.findings.push({
        ...knownVulnerabilities['weak-password-policy'],
        url: `${this.targetUrl}/register`,
        timestamp: new Date()
      });
    }
    
    return vulnerable;
  }
  
  async scanForMissingHeaders() {
    console.log('Scanning for missing security headers...');
    
    // Simulate scanning logic
    const vulnerable = Math.random() > 0.5; // 50% chance of finding vulnerability
    
    if (vulnerable) {
      this.findings.push({
        ...knownVulnerabilities['missing-headers'],
        url: this.targetUrl,
        timestamp: new Date()
      });
    }
    
    return vulnerable;
  }
  
  async runFullScan() {
    console.log(`Running full security scan on ${this.targetUrl}`);
    console.log('==========================================');
    
    await this.scanForSqlInjection();
    await this.scanForXSS();
    await this.scanForCSRF();
    await this.scanForWeakPasswords();
    await this.scanForMissingHeaders();
    
    return this.generateReport();
  }
  
  generateReport() {
    const highSeverity = this.findings.filter(f => f.severity === 'High').length;
    const mediumSeverity = this.findings.filter(f => f.severity === 'Medium').length;
    const lowSeverity = this.findings.filter(f => f.severity === 'Low').length;
    
    return {
      target: this.targetUrl,
      timestamp: new Date(),
      totalFindings: this.findings.length,
      highSeverity,
      mediumSeverity,
      lowSeverity,
      findings: this.findings,
      securityScore: this.calculateSecurityScore()
    };
  }
  
  calculateSecurityScore() {
    const maxScore = 100;
    const penalty = this.findings.reduce((score, finding) => {
      switch (finding.severity) {
        case 'High': return score + 20;
        case 'Medium': return score + 10;
        case 'Low': return score + 5;
        default: return score;
      }
    }, 0);
    
    return Math.max(0, maxScore - penalty);
  }
}

// Security test suite
async function runSecurityTests() {
  console.log('Running Security Vulnerability Scan...');
  console.log('=====================================');
  
  const targetUrl = process.env.SCAN_TARGET || 'http://localhost:3000';
  const scanner = new SecurityScanner(targetUrl);
  
  try {
    const report = await scanner.runFullScan();
    
    console.log('\nSecurity Scan Report:');
    console.log('=====================');
    console.log(`Target: ${report.target}`);
    console.log(`Timestamp: ${report.timestamp}`);
    console.log(`Total Findings: ${report.totalFindings}`);
    console.log(`High Severity: ${report.highSeverity}`);
    console.log(`Medium Severity: ${report.mediumSeverity}`);
    console.log(`Low Severity: ${report.lowSeverity}`);
    console.log(`Security Score: ${report.securityScore}/100`);
    
    if (report.findings.length > 0) {
      console.log('\nDetailed Findings:');
      console.log('------------------');
      report.findings.forEach((finding, index) => {
        console.log(`${index + 1}. ${finding.name} (${finding.severity})`);
        console.log(`   URL: ${finding.url}`);
        console.log(`   Description: ${finding.description}`);
        console.log(`   Detection: ${finding.detection}`);
        console.log('');
      });
    } else {
      console.log('\n✓ No vulnerabilities found!');
    }
    
    // Security assertions
    if (report.securityScore < 80) {
      console.log(`⚠️  Warning: Security score below 80% threshold`);
    }
    
    if (report.highSeverity > 0) {
      console.log(`⚠️  Critical: ${report.highSeverity} high severity vulnerabilities found`);
    }
    
    return report;
  } catch (error) {
    console.error(`✗ Security scan failed: ${error.message}`);
    throw error;
  }
}

// Run the tests
if (require.main === module) {
  runSecurityTests().catch(error => {
    console.error('Security tests failed with error:', error);
    process.exit(1);
  });
}

module.exports = { SecurityScanner, runSecurityTests };